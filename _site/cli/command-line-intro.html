
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146433201-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146433201-1');

</script>
</head>


<link rel="stylesheet" href="/assets/highlight/styles/default.css">

<script src="/assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>

<title>UCD Bioinformatics Core RNA-Seq Workshop</title>

<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.png">

<meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <link rel="icon" type="image/png"  href="/assets/img/favicon.png">
        <title>UC Davis Bioinformatics Workshop Base Template by ucdavis-bioinformatics-training</title>

        <link rel="stylesheet" href="/assets/css/styles.css?v=22a1bf1e038521d63472a401b032dbdd184191bc">
    <meta name="viewport" content="width=device-width">

<body>
    <div style="background-color: #001A46" class="header sticky" id="myHeader" style="width:100%;">
      <a href="https://bioinformatics.ucdavis.edu/training/" class="logo">
          <img src="/assets/img/biocore_banner.png">
      </a>
        <div>
            <h2 style="float: left;padding-left:10px;padding-top:8px;background-color:#CFB53B; cursor:pointer;">
                <div onclick="doNav()">&#9776; Menu </div>
            </h2>
            <h2 style="border-radius: 0px;padding-top:10px;background-color:#CFB53B;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UC Davis Bioinformatics Workshop Base Template</h2>
        </div>
    </div>
</body>


<div>
    <div id="mySidenav" class="sidenav">
      <!-- <a href="javascript:void(0)" class="closebtn" onclick="doNav()">&times;</a> -->

        <table style="padding-top: 50px">
            
                
                
                  <tr><th><a href="/">Home</a></th></tr>
                
            
                
                  <th style="font-size:22px; color:#CFB53B">Introduction</th>
                  
                
                
                  <tr><th><a href="/welcome">Intro to the Workshop and Core</a></th></tr>
                
            
                
                
                  <tr><th><a href="/pdfs/Genomics_a_perspective.pdf">What is Bioinformatics?</a></th></tr>
                
            
                
                
                  <tr><th><a href="/pdfs/ExperimentalDesign.pdf">Experimental Design and Cost Estimation</a></th></tr>
                
            
                
                  <th style="font-size:22px; color:#CFB53B">Command-Line and the Cluster</th>
                  
                
                
                  <tr><th><a href="/cli/logging-in">Logging in and Transferring Files</a></th></tr>
                
            
                
                
                  <tr><th><a href="/cli/command-line-intro">Intro to Command-Line</a></th></tr>
                
            
                
                
                  <tr><th><a href="/cli/advanced-command-line">Advanced Command-Line</a></th></tr>
                
            
                
                
                  <tr><th><a href="/cli/cluster">Running jobs on the Cluster and using modules</a></th></tr>
                
            
                
                  <th style="font-size:22px; color:#CFB53B">Intro to R and Rstudio</th>
                  
                
                
                  <tr><th><a href="/intro2R/RStudio">Getting Started</a></th></tr>
                
            
                
                
                  <tr><th><a href="/intro2R/Intro2R">Intro to R</a></th></tr>
                
            
                
                
                  <tr><th><a href="/intro2R/data_in_R_prepare">Prepare Data in R (extra)</a></th></tr>
                
            
                
                
                  <tr><th><a href="/intro2R/orig_data_in_R">Data in R (extra)</a></th></tr>
                
            
                
                  <th style="font-size:22px; color:#CFB53B">Data Reduction</th>
                  
                
                
                  <tr><th><a href="/data_reduction/filetypes">Files and Filetypes for RNA-Seq</a></th></tr>
                
            
                
                
                  <tr><th><a href="/data_reduction/project_setup">Project Setup</a></th></tr>
                
            
                
                
                  <tr><th><a href="/data_reduction/preproc_htstream">Preprocessing Data</a></th></tr>
                
            
                
                
                  <tr><th><a href="/data_reduction/alignment">Aligners</a></th></tr>
                
            
                
                
                  <tr><th><a href="/data_reduction/counts">Generating Summarized Counts</a></th></tr>
                
            
                
                
                  <tr><th><a href="/data_reduction/salmon">Salmon</a></th></tr>
                
            
                
                  <th style="font-size:22px; color:#CFB53B">Support</th>
                  
                
                
                  <tr><th><a href="/cheatSheetIndex">Cheat Sheets</a></th></tr>
                
            
                
                
                  <tr><th><a href="/software">Software and Links</a></th></tr>
                
            
                
                
                  <tr><th><a href="/script_links">Scripts</a></th></tr>
                
            
                
                  <th style="font-size:22px; color:#CFB53B">Differential Expression and Pathway Analysis</th>
                  
                
                
                  <tr><th><a href="/differential_expression/de_analysis_prepare">Prepare Differential Expression Analysis</a></th></tr>
                
            
                
                
                  <tr><th><a href="/differential_expression/annotation">Get Gene Annotation</a></th></tr>
                
            
                
                
                  <tr><th><a href="/differential_expression/DE_Analysis">Differential Expression Analysis</a></th></tr>
                
            
                
                
                  <tr><th><a href="/differential_expression/enrichment">Pathway Analysis</a></th></tr>
                
            
                
                
                  <tr><th><a href="/differential_expression/compare_star_salmon">Comparison between STAR and Salmon</a></th></tr>
                
            
                
                  <th style="font-size:22px; color:#CFB53B">ETC</th>
                  
                
                
                  <tr><th><a href="/closing">Closing thoughts</a></th></tr>
                
            
                
                
                  <tr><th><a href="/photos/photos">Workshop Photos</a></th></tr>
                
            
                
                
                  <tr id=Github ><th><a href="https://github.com/ucdavis-bioinformatics-training/2019_August_UCD_mRNAseq_Workshop">Github</a></th></tr>
                
            
                
                
                  <tr id=Biocore website ><th><a href="http://bioinformatics.ucdavis.edu">Biocore website</a></th></tr>
                
            
        </table>
    </div>
</div>


<div id="main" style="padding-left: 50px; padding-right: 50px; margin-left: 300px; padding-top:170px">

<h1 id="introduction-to-command-line-interface">Introduction to Command Line Interface</h1>

<h2 id="what-is-the-command-line">What is the command line</h2>

<ul>
  <li>CLI is a tool into which one can type commands to perform tasks.</li>
  <li>The user interface that accepts the typed responses and displays the data on the screen is called a shell: bash, tcsh…</li>
  <li>An all-text display (most of the time your mouse doesn’t work)</li>
</ul>

<p><img src="figures/cli_figure1.png" alt="cli_figure1" width="800px" /></p>

<p>A greater than sign (&gt;) instead of a prompt means the shell is expecting more input. Can Cntr-c to cancel the operation and return to a prompt.</p>

<h2 id="directory-structure">Directory Structure</h2>

<p>Absolute path: always starts with ”/”</p>

<p>/share/workshop/msettles/cli</p>

<p>the folder (or file) cli in the folder msettles in the folder workship in the folder share from root.</p>

<p>Relative path: always relative to our current location.</p>

<p><em>a single dot (.) refers to the current directory</em><br />
<em>two dots (..) refers to the directory one level up</em></p>

<p><img src="figures/cli_figure2.png" alt="cli_figure2" width="500px" /></p>

<p>Usually, /home is where the user accounts reside, ie. user’s ‘home’ directory.
For example, for a user that has a username of “msettles”: their home directory is /home/msettles
It is the directory that a user is located after starting a new shell or logging into a remote server .</p>

<p>The tilde (~) is a short form of a user’s home directory.</p>

<h2 id="syntax-of-a-command">Syntax of a command</h2>

<ul>
  <li>A command plus the required parameters/arguments</li>
  <li>The separator used in issuing a command is space, number of spaces does not matter</li>
</ul>

<p><img src="figures/cli_figure3.png" alt="cli_figure3" width="800px" /></p>

<h2 id="logging-into-a-remote-server">Logging into a remote server</h2>

<p>For this we use the application Secure SHell … SSH. Replace ‘username’ with your login name in the following and enter your password when prompted. You will not see your password being typed.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh username@tadpole.genomecenter.ucdavis.edu
</code></pre></div></div>

<p>for example my login is</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh msettles@tadpole.genomecenter.ucdavis.edu
</code></pre></div></div>

<p>Once you’re done working on the command line, you can exit. Anything that follows the character ‘#’ is ignored.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exit  # kills the current shell!
</code></pre></div></div>

<p><img src="figures/cli_figure4.png" alt="cli_figure4" width="800px" /></p>

<p>Go ahead and log back into the server.</p>

<p>After opening, system messages are often displayed, followed by the “prompt”.
A prompt is a short text message at the start of the command line and ends with ‘$’ in bash shell, commands are typed after the prompt.
The prompt typically follows the form <strong>username@server:location$</strong></p>

<h2 id="command-line-basics">Command Line Basics</h2>

<p>First some basics - how to look at your surroundings.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwd
</code></pre></div></div>

<p>present working directory … where am I?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls .  
</code></pre></div></div>

<p>list files here … you should see nothing since your homes are empty</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls /tmp/
</code></pre></div></div>

<p>list files somewhere else, like /tmp/</p>

<p>Because one of the first things that’s good to know is <em>how to escape once you’ve started something you don’t want</em>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sleep 1000  # wait for 1000 seconds!
</code></pre></div></div>

<p>Use Ctrl-c (shows as ‘^C’ in screen) to exit (kill) a command. In some cases, a different key sequence is required (Ctrl-d).</p>

<h4 id="options">Options</h4>

<p>Each command can act as a basic tool, or you can add ‘options’ or ‘flags’ that modify the default behavior of the tool. These flags come in the form of ‘-v’ … or, when it’s a more descriptive word, two dashes: ‘--verbose’ … that’s a common (but not universal) one that tells a tool that you want it to give you output with more detail. Sometimes, options require specifying amounts or strings, like ‘-o results.txt’ or ‘--output results.txt’ … or ‘-n 4’ or ‘--numCPUs 4’. Let’s try some, and see what the man page for the ‘list files’ command ‘ls’ is like.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls -R /
</code></pre></div></div>

<p>Lists directories and files <em>recursively</em>. how do I know which options do what?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man ls
</code></pre></div></div>

<p>Navigate like in ‘less’ (up,down,pgup,pgdn,g,G,/pattern,n,N,q), look up and try the following, if you don’t say where, it lists files in your current directory</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls -l
ls -a
ls -l -a
ls -la  # option 'smushing' ... when no values need specifying
ls -ltrha
</code></pre></div></div>

<p>And finally adding color:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls -ltrha --color  # single letter (smushed) vs word options (Linux)
</code></pre></div></div>

<p><strong>OR</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls -ltrhaG  # (MacOS)
</code></pre></div></div>

<p>Quick aside: what if I want to use same options repeatedly? and be lazy? You can create a shortcut to another command using ‘alias’.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alias ll='ls -lah'
ll
</code></pre></div></div>

<h2 id="getting-around">Getting Around</h2>

<p>The filesystem you’re working on is like the branching root system of a tree. The top level, right at the root of the tree, is called the ‘root’ directory, specified by ‘/’ … which is the divider for directory addresses, or ‘paths’. We move around using the ‘change directory’ command, ‘cd’. The command pwd return the present working directory.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd  # no effect? that's because by itself it sends you home (to ~)
cd /  # go to root of tree's root system
cd home  # go to where everyone's homes are
pwd
cd username  # use your actual home, not "username"
pwd
cd /
pwd
cd ~  # a shortcut to home, from anywhere
pwd
cd .  # '.' always means *this* directory
pwd
cd ..  # '..' always means *one directory up*
pwd
</code></pre></div></div>

<p><img src="figures/cli_figure5.png" alt="cli_figure5" width="800px" /></p>

<p>You should also notice the location changes in your prompt.</p>

<h2 id="absolute-and-relative-paths">Absolute and Relative Paths</h2>

<p>You can think of paths like addresses. You can tell your friend how to go to a particular store <em>from where they are currently</em> (a ‘relative’ path), or <em>from the main Interstate Highway that everyone uses</em> (in this case, the root of the filesystem, ‘/’ … this is an ‘absolute’ path). Both are valid. But absolute paths can’t be confused, because they always start off from the same place. Relative paths, on the other hand, could be totally wrong for your friend <em>if you assume they’re somewhere they’re not</em>. With this in mind, let’s try a few more:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~  # let's start at home
</code></pre></div></div>

<p><strong>relative</strong> (start here, take two steps up, then down through share and workshop)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ../../share/workshop/
pwd
</code></pre></div></div>

<p><strong>absolute</strong> (start at root, take steps)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /share/workshop/
pwd
</code></pre></div></div>

<p>Now, because it can be a real pain to type out, or remember these long paths, we need to discuss …</p>

<h2 id="tab-completion">Tab Completion</h2>

<p>Using tab-completion is a must on the command line. A single <tab> auto-completes file or directory names when there's only one name that could be completed correctly. If multiple files could satisfy the tab-completion, then nothing will happen after the first <tab>. In this case, press <tab> a second time to list all the possible completing names. Note that if you've already made a mistake that means that no files will ever be completed correctly from its current state, then <tab>'s will do nothing.</tab></tab></tab></tab></p>

<p>touch updates the timestamp on a file, here we use it to create three empty files.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>touch one seven september
ls o
</code></pre></div></div>

<p>tab with no enter should complete to ‘one’, then enter</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls s
</code></pre></div></div>

<p>tab with no enter completes up to ‘se’ since that’s in common between seven and september. tab again and no enter, this second tab should cause listing of seven and september. type ‘v’ then tab and no enter now it’s unique to seven, and should complete to seven. enter runs ‘cat seven’ command.</p>

<p>I can’t overstate how useful tab completion is. You should get used to using it constantly. Watch experienced users type and they maniacally hit tab once or twice in between almost every character. You don’t have to go that far, of course, but get used to constantly getting feedback from hitting tab and you will save yourself a huge amount of typing and trying to remember weird directory and filenames.</p>

<h4 id="challenge">CHALLENGE</h4>

<p>After returning to your home directory (just enter ‘cd’ by itself), verify that the two following commands are equivalent (replacing ‘username’ with your actual username):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ../../home/username/
cd ../../../../../../../home/username/
</code></pre></div></div>

<p>Why are these very different-looking commands equivalent??</p>

<h2 id="create-and-destroy">Create and Destroy</h2>

<p>We already learned one command that will create a file, touch. Lets create a folder in /share/workshop for you to work in and then another directory cli. We will use the environment variable $USER, that is your username.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd  # home again
echo $USER # echo to screen the contents of the variable $USER
mkdir ~/cli
cd ~/cli
echo 'Hello, world!' &gt; first.txt
</code></pre></div></div>

<p>echo text then redirect (‘&gt;’) to a file.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat first.txt  # 'cat' means 'concatenate'
</code></pre></div></div>

<p>why ‘concatenate’? try this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat first.txt first.txt first.txt &gt; second.txt
cat second.txt
</code></pre></div></div>

<p>OK, let’s destroy what we just created:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ../
rmdir tmp  # 'rmdir' meands 'remove directory', but this shouldn't work!
rm tmp/first.txt
rm tmp/second.txt  # clear directory first
rmdir tmp  # should succeed now
</code></pre></div></div>

<p>So, ‘mkdir’ and ‘rmdir’ are used to create and destroy (empty) directories. ‘rm’ to remove files. To create a file can be as simple as using ‘echo’ and the ‘&gt;’ (redirection) character to put text into a file. Even simpler is the ‘touch’ command.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>touch newFile
ls -ltra  # look at the time listed for the file you just created
cat newFile  # it's empty!
sleep 60  # go grab some coffee
touch newFile
ls -ltra  # same time?
</code></pre></div></div>

<p>So ‘touch’ creates empty files, or updates the ‘last modified’ time. Note that the options on the ‘ls’ command you used here give you a Long listing, of All files, in Reverse Time order (l, a, r, t).</p>

<h2 id="piping-and-redirection">Piping and Redirection</h2>

<p>Pipes (‘|’) allow commands to hand output to other commands, and redirection characters (‘&gt;’ and ‘»’) allow you to put output into files.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo 'first' &gt; test.txt
cat test.txt
echo 'second' &gt; test.txt
cat test.txt
echo 'third' &gt;&gt; test.txt
cat test.txt
</code></pre></div></div>

<p>The ‘&gt;’ character redirects output of a command that would normally go to the screen instead into a specified file. ‘&gt;’ replaces, ‘»’ appends.</p>

<p>cuts character one to three, from every line, from file ‘test.txt’</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cut -c 1-3 test.txt  
</code></pre></div></div>

<p>same thing, piping output of one command into input of another</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat test.txt | cut -c 1-3  
</code></pre></div></div>

<p>pipes cat to cut to sort (-r means reverse order sort), and then grep searches for pattern (‘s’) matches.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat test.txt | cut -c 1-3 | sort -r
cat test.txt | cut -c 1-3 | sort -r | grep s
</code></pre></div></div>

<p>This is a great way to build up a set of operations while inspecting the output of each step in turn. We’ll do more of this in a bit.</p>

<h2 id="history-repeats-itself">History Repeats Itself</h2>

<p>Linux remembers everything you’ve done (at least in the current shell session), which allows you to pull steps from your history, potentially modify them, and redo them. This can obviously save a lot of time and typing.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;up arrow&gt;  # last command
&lt;up&gt;  # next-to-last command
&lt;down&gt;  # last command, again
&lt;down&gt;  # current command, empty or otherwise
history  # usually too much for one screen, so ...
history | head
history | tail
history | tail -n 30
history | less
cat test.txt | cut -c 1-3 | sort -r | grep s &gt; reallyImportantResult.txt
rm reallyImportantResult.txt  # whoops! didn't mean to do that!
history | tail
!560  # re-executes 560th command (yours will have different numbers; choose the one that recreates your really important result!)
</code></pre></div></div>

<p>You can also search your history from the command line:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;ctrl-r&gt;fir  # should find most recent command containing 'fir' string: echo 'first' &gt; test.txt
&lt;enter&gt;  # to run command
&lt;ctrl-c&gt;  # get out of recursive search
&lt;ctr-r&gt;  # repeat &lt;ctrl-r&gt; to find successively older string matches
</code></pre></div></div>

<h3 id="challenge-1">CHALLENGE</h3>

<p>What’s the first command you executed today? How many times have you used the ‘man’ command today? Whatever that number is, it should be more! Just kidding. Sort of.</p>

<h3 id="challenge-2">CHALLENGE</h3>

<p>The ‘head’ and ‘tail’ commands view the first 10 (by default) lines of a file and last 10 lines of a file (type ‘man head’ or ‘man tail’ to consult their manuals). How would you create a second text file - let’s say ‘test2.txt’ - with the line that says ‘third’ <em>before</em> the line that says ‘second’? Without directly editing the file with a text editor, of course ..</p>

<h2 id="editing-yourself">Editing Yourself</h2>
<p>Here are some more ways to make editing previous commands, or novel commands that you’re building up, easier:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;up&gt;&lt;up&gt;  # go to some previous command, just to have something to work on
&lt;ctrl-a&gt;  # go to the beginning of the line
&lt;ctrl-e&gt;  # go to the end of the line
# now use left and right to move to a single word (surrounded by whitespace: spaces or tabs)
&lt;ctrl-k&gt;  # delete from here to end of line
&lt;ctrl-w&gt;  # delete from here to beginning of preceeding word
blah blah blah&lt;ctrl-w&gt;&lt;ctrl-w&gt;  # leaves you with only one 'blah'
</code></pre></div></div>

<h2 id="compression-and-archives">Compression and Archives</h2>

<p>As file sizes get large, you’ll often see compressed files, or whole compressed folders.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gzip test.txt
cat test.txt.gz
</code></pre></div></div>

<p>To uncompress a file</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gunzip -c test.txt.gz
</code></pre></div></div>

<p>The ‘-c’ leaves the original file alone, but dumps expanded output to screen</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gunzip test.txt.gz  # now the file should change back to uncompressed test.txt
</code></pre></div></div>

<p>Tape archives, or .tar files, are one way to compress entire folders and all contained folders into one file. When they’re further compressed they’re called ‘tarballs’. We can use wget (web get).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget ftp://igenome:G3nom3s4u@ussd-ftp.illumina.com/PhiX/Illumina/RTA/PhiX_Illumina_RTA.tar.gz
</code></pre></div></div>

<p>The .tar.gz and .tgz are <em>commonly used</em> extensions for compressed tar files, when gzip compression is used. The application tar is used to uncompress .tar files</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -xzvf PhiX_Illumina_RTA.tar.gz
</code></pre></div></div>

<p>Here -x = extract, -z = use gzip/gunzip, -v = verbose (show each file in archive), -f filename</p>

<p>Note that, unlike Windows, linux does not depend on file extensions to determine file behavior. So you could name a tarball ‘fish.puppy’ and the extract command above should work just fine. The only thing that should be different is that tab-completion doesn’t work within the ‘tar’ command if it doesn’t see the ‘correct’ file extension.</p>

<h2 id="forced-removal">Forced Removal</h2>

<p>When you’re on the command line, there’s no ‘Recycle Bin’. Since we’ve expanded a whole directory tree, we need to be able to quickly remove a directory without clearing each subdirectory and using ‘rmdir’.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm -rf PhiX
</code></pre></div></div>

<p>Here -r = recursively remove sub-directories, -f means <em>force</em>. We actually want to use those directories, so un-archive them again!</p>

<p>Obviously, be careful with ‘rm -rf’, there is no going back, if you delete something with rm, rmdir its gone!</p>

<h2 id="bash-wildcard-characters">BASH Wildcard Characters</h2>

<p>When we want to specify or operate on sets of files all at once.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls ?hiX/Illumina
</code></pre></div></div>

<p>list files in Illumina sub-directory of any directory ending in ‘hiX’</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls PhiX/Illumina/RTA/Sequence/*/*.fa
</code></pre></div></div>

<p>list all .fa files a few directories down. So, ‘?’ fills in for zero or one character, ‘*’ fills in for zero or more characters. find can be used to locate files of a server form.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -name "*.f*"
find . -name "*.f?"
</code></pre></div></div>

<p>how are this different from the previous command?</p>

<h4 id="quick-note-about-the-quotes">Quick Note About the Quote(s)</h4>

<p>The quote characters “ and ‘ are different. In general, single quotes preserve the <em>literal</em> meaning of all characters between them. On the other hand, double quotes allow the shell to see what’s between them and make substitutions when appropriate. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VRBL=someText
echo '$VRBL'
echo "$VRBL"
</code></pre></div></div>

<p>However, some commands try to be ‘smarter’ about this behavior, so it’s a little hard to predict what will happen in all cases. It’s safest to experiment first when planning a command that depends on quoting … list filenames first, instead of changing them, etc. Finally, the ‘backtic’ characters ` (same key - unSHIFTED - as the tilde ~) causes the shell to interpret what’s between them as a command, and return the result.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo `$VRBL`  # tries to execute a command with the name *someText*
newVRBL=`echo $VRBL`
echo $newVRBL
</code></pre></div></div>

<h2 id="manipulation-of-a-fasta-file">Manipulation of a FASTA File</h2>

<p>We just found the phiX-174 genome, so let’s copy it to our current directory so we can play with it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp ./PhiX/Illumina/RTA/Sequence/WholeGenomeFasta/genome.fa phix.fa
</code></pre></div></div>

<p>Note how we copied the ‘genome.fa’ file to a different name: ‘phix.fa’</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wc -l phix.fa
</code></pre></div></div>

<p>count the number of lines in the file using ‘wc’ (word count) and parameter ‘-l’ (lines).</p>

<p>We can use the ‘grep’ command to search for matches to patterns. ‘grep’ comes from ‘<strong>g</strong>lobally search for a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint’.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep -c '&gt;' phix.fa
</code></pre></div></div>

<p>Only one FASTA sequence entry, since only one header line (‘&gt;gi|somethingsomething…’)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat phix.fa
</code></pre></div></div>

<p>This may not be useful for anything larger than a virus! Let’s look at start codon and 2 following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep --color "ATG......" phix.fa
</code></pre></div></div>

<p>’.’ characters are the single-character wildcards for grep</p>

<p>Use the –color  ‘-o’ option to <strong>o</strong>nly print the pattern matches, one per line</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep -o "ATG......" phix.fa
</code></pre></div></div>

<p>Use the ‘cut’ command with ‘-c’ to select characters 4-6, the second codon</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep --color  -o "ATG......" phix.fa | cut -c4-6
</code></pre></div></div>

<p>‘sort’ the second codon sequences (default order is same as ASCII table; see ‘man ascii’)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep --color  -o "ATG......" phix.fa | cut -c4-6 | sort
</code></pre></div></div>

<p>Combine successive identical sequences, but count them (‘-c’ option)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep --color  -o "ATG......" phix.fa | cut -c4-6 | sort | uniq -c
</code></pre></div></div>

<p>Finally sort using reverse numeric order (‘-rn’)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep --color  -o "ATG......" phix.fa | cut -c4-6 | sort | uniq -c | sort -rn 
</code></pre></div></div>

<p>… which gives us the most common codons first</p>

<p>This may not be a particularly useful thing to do with a genomic FASTA file, but it illustrates the process by which one can build up a string of operations, using pipes, in order to ask quantitative questions about sequence content. More generally than that, this process allows one to ask questions about files and file contents and the operating system, and verify at each step that the process so far is working as expected. The command line is, in this sense, really a modular workflow management system.</p>

<h3 id="challenge-3">CHALLENGE</h3>

<p>Many programs and data archives contain files named something like ‘readme’ or ‘README’ that contains important information for the user. How many of these files are there in the PhiX directory tree? How would you look at their contents?</p>

<h2 id="symbolic-links">Symbolic Links</h2>

<p>Since copying or even moving large files (like sequence data) around your filesystem may be impractical, we can use links to reference ‘distant’ files without duplicating the data in the files. Symbolic links are disposable pointers that refer to other files, but behave like the referenced files in commands.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ln -s PhiX/Illumina/RTA/Sequence/WholeGenomeFasta/genome.fa .
ls -ltrhaF  # notice the symbolic link pointing at its target
grep -c "&gt;" genome.fa
</code></pre></div></div>

<h2 id="stdout--stderr">STDOUT &amp; STDERR</h2>

<p>Programs can write to two separate output streams, ‘standard out’ (STDOUT), and ‘standard error’ (STDERR). The former is generally for direct output of a program, while the latter is supposed to be used for reporting problems. I’ve seen some bioinformatics tools use STDERR to report summary statistics about the output, but this is probably bad practice. Default behavior in a lot of cases is to dump both STDOUT and STDERR to the screen, unless you specify otherwise. In order to nail down what goes where, and record it for posterity:</p>

<pre><code class="language-Bash">wc -c genome.fa 1&gt; chars.txt 2&gt; any.err
</code></pre>

<p>the 1st output, STDOUT, goes to ‘chars.txt’<br />
the 2nd output, STDERR, goes to ‘any.err’</p>

<pre><code class="language-Bash">cat chars.txt
</code></pre>

<p>Contains the character count of the file genome.fa</p>

<pre><code class="language-Bash">cat any.err
</code></pre>

<p>Empty since no errors occured.</p>

<p>Saving STDOUT is pretty routine (you want your results, yes?), but remember that explicitly saving STDERR is important on a remote server, since you may not directly see the ‘screen’ when you’re running jobs.</p>

<h2 id="paste-command">Paste Command</h2>

<p>The paste command is useful in creating tables.</p>

<pre><code class="language-Bash">echo 'WT1' &gt; b
echo 'WT2' &gt;&gt; b
echo 'control1' &gt;&gt; b
echo 'control2' &gt;&gt; b
cat b
</code></pre>

<p>Now we can number our four samples to conveniently refer to them in order</p>

<pre><code class="language-Bash">for i in {1..4}; do echo $i &gt;&gt; a; done
cat a
paste a b &gt; c
cat c
</code></pre>

<h2 id="running-in-the-background">Running in the Background</h2>

<p>Sometimes it’s useful to continue working on the command line, even after you’ve executed a command that’s going to take a while to finish. Normally this command would occupy the shell, and prevent you from typing in commands and receiving results. But we can ‘put jobs in the background’ so that they don’t occupy your shell directly:</p>

<pre><code class="language-Bash">sleep 1000000
</code></pre>

<p>Ctrl-Z to pause (stop) the command</p>

<pre><code class="language-Bash">bg
</code></pre>

<p>To restart the last command in the background</p>

<p>‘^Z’ first suspends the sleep command. Then, ‘bg’ resumes running that command <em>in the background</em>, so that it doesn’t occupy the terminal. The output of the ‘bg’ command tells you that you have one command running in the background. You could start more, suspend them, then resume them in the background, and query what background jobs are running or are suspended, not running:</p>

<pre><code class="language-Bash">jobs
</code></pre>

<div class="output">[1]+  Running                 sleep 1000000 &amp;
</div>

<p>We can also start a job in the background in one step, without having to suspend then resume it, using the ‘&amp;’ character at the end of the command:</p>

<pre><code class="language-Bash">sleep 5000000 &amp;
</code></pre>
<p>If we want to delete these jobs for any reason, we can kill them using the numbering that ‘jobs’ reveals:</p>

<pre><code class="language-Bash">jobs
</code></pre>

<div class="output">[1]-  Running                 sleep 1000000 &amp;
[2]+  Running                 sleep 5000000 &amp;
</div>

<pre><code class="language-Bash">kill %1
jobs
</code></pre>

<div class="output">[1]-  Terminated              sleep 1000000
[2]+  Running                 sleep 5000000 &amp;
</div>

<pre><code class="language-Bash">kill %2
jobs
</code></pre>

<div class="output">[2]+  Terminated              sleep 5000000
</div>

<p>Finally, the ‘nohup’ command (from ‘no hangup’!) makes jobs extra resistant to lost connections or terminal problems. In other words, even jobs running in the background can be terminated if one’s shell dies. ‘nohup’ separates the running job from the shell, so it’ll keep running until it dies or is actively killed by you.</p>

<pre><code class="language-Bash">nohup sleep 1000000 &amp;
</code></pre>

<div class="output">[1] 34993
username@c4-0:~/CLB$ nohup: ignoring input and appending output to nohup.out
</div>

<pre><code class="language-Bash">jobs
</code></pre>

<div class="output">[1]+  Running                 nohup sleep 1000000 &amp;
</div>

<p>output is dumped into the ‘nohup.out’ file unless specifically redirected in your command</p>

<pre><code class="language-Bash">kill %1
</code></pre>

<p>If you used bg to send a process to the background you can use ‘disown’ to “nohup” the process</p>

<h2 id="table-of-processes-top">Table of Processes (top)</h2>

<p>The ‘top’ command prints a self-updating table of running processes and system stats. Use ‘q’ to exit top, ‘z’ to toggle better color contrast, ‘M’ to sort by memory use, ‘P’ to sort by processor use, and ‘c’ to toggle display of the full commands. Hit ‘1’ to toggle display of all processors, and hit ‘u’ followed by typing in a username in order to only show processes (jobs) owned by that user.</p>

<p><img src="figures/cli_figure6.png" alt="cli_figure6" width="800px" /></p>

<h2 id="shell-scripts-file-permissions">Shell Scripts, File Permissions</h2>

<p>Often it’s useful to define a whole string of commands to run on some input, so that (1) you can be sure you’re running the same commands on all data, and (2) so you don’t have to type the same commands in over and over! Let’s use the ‘nano’ text editor program that’s pretty reliably installed on most linux systems.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    nano test.sh
</code></pre></div></div>

<p><img src="figures/cli_figure7.png" alt="cli_figure7" width="800px" /></p>

<p>nano now occupies the whole screen; see commands at the bottom
type/paste in the following …
(note that ‘#!’ is an interpreted command to the shell, not a comment)</p>

<pre class="prettyprint"><code class="language-sh" style="background-color:333333">
#!/bin/bash
grep -o . $1 | \
    sort | \
    uniq -c | \
    sort -rn -k1,1
</code></pre>

<p>Cntrl-X top exit first saving the document. Follow the instruction at the bottom of the screen</p>

<p>Note that ‘$1’ means ‘the value of the 1st argument to the shell script’ … in other words, the text that follows the shell script name when we run it (see below).</p>

<p>Though there are ways to run the commands in test.sh right now, it’s generally useful to give yourself (and others) ‘execute’ permissions for test.sh, really making it a shell script. Note the characters in the first (left-most) field of the file listing:</p>

<pre><code class="language-Bash">ls -lh test.sh
</code></pre>

<div class="output">-rw-rw-r-- 1 msettles biocore 79 Aug 19 15:05 test.sh
</div>

<p>The first ‘-‘ becomes a ‘d’ if the ‘file’ is actually a directory. The next three characters represent <strong>r</strong>ead, <strong>w</strong>rite, and e<strong>x</strong>ecute permissions for the file owner (you), followed by three characters for users in the owner’s group, followed by three characters for all other users. Run the ‘chmod’ command to change permissions for the ‘test.sh’ file, adding execute permissions (‘+x’) for the user (you) and your group (‘ug’):</p>

<pre><code class="language-Bash">chmod ug+x test.sh
ls -lh test.sh
</code></pre>

<div class="output">-rwxr-xr-- 1 msettles biocore 79 Aug 19 15:05 test.sh
</div>

<p>OK! So let’s run this script, feeding it the phiX genome. When we put the genome file 1st after the name of the script, this filename becomes variable ‘1’, which the script can access by specifying ‘$1’. We have to provide a relative reference to the script ‘./’ because its not our our “PATH”.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ./test.sh genome.fa
</code></pre></div></div>

<div class="output">msettles@tadpole:/share/workshop/msettles/cli$ ./test.sh genome.fa
    1686 T
    1292 A
    1253 G
    1155 C
       1 x
       1 p
       1 i
       1 h
       1 &gt;
</div>

<p>The script’s grep command splits out every character in the file on a separate line, then sorts them so it can count the occurrences of every unique character and show the most frequent characters first … a quick and dirty way to get at GC content.</p>


</div>



<script src="/assets/js/scale.fix.js"></script>

<script>
var navopen=1;

function doNav() {
  if (navopen == 1) {
    document.getElementById("mySidenav").style.width = "0px";
    document.getElementById("main").style.marginLeft = "0px";
    document.getElementById("myHeader").style.marginLeft = "0px";
    document.getElementById("mySidenav").style.overflowY = "hidden";
    navopen = 0;
  } else {
    document.getElementById("mySidenav").style.width = "300px";
    document.getElementById("main").style.marginLeft = "300px";
    document.getElementById("myHeader").style.marginLeft = "300px";
    document.getElementById("mySidenav").style.overflowY = "visible";
    navopen = 1;
  }
}

// When the user scrolls the page, execute myFunction
window.onscroll = function() {myFunction()};

// store the sidenav scroll pos for loading or set the pos
sn = document.getElementById("mySidenav");
sn.onscroll = function() {sessionStorage.setItem("scrollpos",sn.scrollTop);};
window.onload = function() {sn.scrollTop = sessionStorage.getItem("scrollpos");};

// Get the header
var header = document.getElementById("myHeader");

// Get the offset position of the navbar
var sticky = header.offsetTop;


function myFunction() {
  var x = document.getElementById("myDIV");
  if (x.style.display === "none") {
    x.style.display = "block";
  } else {
    x.style.display = "none";
  }
}

</script>
